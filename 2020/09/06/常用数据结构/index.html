<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>常用数据结构 | 派大星之卡比兽</title><meta name="description" content="Stackstack.h#include &lt;stdbool.h&gt;typedef struct StackRep *stack;stack newStack();             &#x2F;&#x2F; set up empty stackvoid  dropStack(stack);       &#x2F;&#x2F; remove unwanted stackbool  StackIsEmpty(stack);"><meta name="keywords" content="数据结构和算法,COMP9024"><meta name="author" content="Louie Zedd"><meta name="copyright" content="Louie Zedd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon1.png"><link rel="canonical" href="http://example.com/2020/09/06/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="常用数据结构"><meta property="og:url" content="http://example.com/2020/09/06/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="派大星之卡比兽"><meta property="og:description" content="Stackstack.h#include &lt;stdbool.h&gt;typedef struct StackRep *stack;stack newStack();             &#x2F;&#x2F; set up empty stackvoid  dropStack(stack);       &#x2F;&#x2F; remove unwanted stackbool  StackIsEmpty(stack);"><meta property="og:image" content="http://example.com/img/Michael.png"><meta property="article:published_time" content="2020-09-06T14:01:18.000Z"><meta property="article:modified_time" content="2020-09-16T12:38:05.863Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Louie Zedd","link":"链接: ","source":"来源: 派大星之卡比兽","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-16 20:38:05'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack"><span class="toc-number">1.</span> <span class="toc-text">Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack-h"><span class="toc-number">1.1.</span> <span class="toc-text">stack.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack-c"><span class="toc-number">1.2.</span> <span class="toc-text">stack.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-number">2.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-h"><span class="toc-number">2.1.</span> <span class="toc-text">queue.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-c"><span class="toc-number">2.2.</span> <span class="toc-text">queue.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list-h"><span class="toc-number">3.1.</span> <span class="toc-text">list.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-c"><span class="toc-number">3.2.</span> <span class="toc-text">list.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph"><span class="toc-number">4.</span> <span class="toc-text">Graph</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#graph-h"><span class="toc-number">4.1.</span> <span class="toc-text">graph.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#graph-c-Adjacency-Matrix"><span class="toc-number">4.2.</span> <span class="toc-text">graph.c(Adjacency Matrix)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#graph-c-Adjacency-List"><span class="toc-number">4.3.</span> <span class="toc-text">graph.c(Adjacency List)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#graph-c-Adjacency-List-1"><span class="toc-number">4.4.</span> <span class="toc-text">graph.c(Adjacency List)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Weighted-Graph"><span class="toc-number">5.</span> <span class="toc-text">Weighted Graph</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WGraph-h"><span class="toc-number">5.1.</span> <span class="toc-text">WGraph.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WGraph-c"><span class="toc-number">5.2.</span> <span class="toc-text">WGraph.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST"><span class="toc-number">6.</span> <span class="toc-text">BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BST-h"><span class="toc-number">6.1.</span> <span class="toc-text">BST.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BST-c"><span class="toc-number">6.2.</span> <span class="toc-text">BST.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RBT"><span class="toc-number">7.</span> <span class="toc-text">RBT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RBT-h"><span class="toc-number">7.1.</span> <span class="toc-text">RBT.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RBT-c"><span class="toc-number">7.2.</span> <span class="toc-text">RBT.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie"><span class="toc-number">8.</span> <span class="toc-text">Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie-h"><span class="toc-number">8.1.</span> <span class="toc-text">Trie.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie-c"><span class="toc-number">8.2.</span> <span class="toc-text">Trie.c</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/2am.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派大星之卡比兽</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">常用数据结构</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-06T14:01:18.000Z" title="发表于 2020-09-06 22:01:18">2020-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-16T12:38:05.863Z" title="更新于 2020-09-16 20:38:05">2020-09-16</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><h4 id="stack-h"><a href="#stack-h" class="headerlink" title="stack.h"></a>stack.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackRep</span> *<span class="title">stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">stack</span> <span class="title">newStack</span><span class="params">()</span></span>;             <span class="comment">// set up empty stack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">dropStack</span><span class="params">(<span class="built_in">stack</span>)</span></span>;       <span class="comment">// remove unwanted stack</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">StackIsEmpty</span><span class="params">(<span class="built_in">stack</span>)</span></span>;    <span class="comment">// check whether stack is empty</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">StackPush</span><span class="params">(<span class="built_in">stack</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// insert an int on top of stack</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">StackPop</span><span class="params">(<span class="built_in">stack</span>)</span></span>;        <span class="comment">// remove int from top of stackack, int);  // insert an int on top of stack</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">StackPop</span><span class="params">(<span class="built_in">stack</span>)</span></span>;        <span class="comment">// remove int from top of stack</span></span><br></pre></td></tr></table></figure>

<h4 id="stack-c"><a href="#stack-c" class="headerlink" title="stack.c"></a>stack.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; NodeT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackRep</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    height;   <span class="comment">// #elements on stack</span></span><br><span class="line">    NodeT *top;      <span class="comment">// ptr to first element</span></span><br><span class="line">&#125; StackRep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up empty stack</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span> <span class="title">newStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> S = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackRep));</span><br><span class="line">    assert(S != <span class="literal">NULL</span>);</span><br><span class="line">    S-&gt;height = <span class="number">0</span>;</span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Stack ADT implementation ... COMP9024 20T2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; NodeT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackRep</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    height;   <span class="comment">// #elements on stack</span></span><br><span class="line">    NodeT *top;      <span class="comment">// ptr to first element</span></span><br><span class="line">&#125; StackRep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up empty stack</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span> <span class="title">newStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> S = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackRep));</span><br><span class="line">    assert(S != <span class="literal">NULL</span>);</span><br><span class="line">    S-&gt;height = <span class="number">0</span>;</span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove unwanted stack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dropStack</span><span class="params">(<span class="built_in">stack</span> S)</span> </span>&#123;</span><br><span class="line">    NodeT *curr = S-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NodeT *temp = curr-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether stack is empty</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackIsEmpty</span><span class="params">(<span class="built_in">stack</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;height == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert an int on top of stack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(<span class="built_in">stack</span> S, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    NodeT *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NodeT));</span><br><span class="line">    assert(<span class="keyword">new</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = v;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = S-&gt;top;</span><br><span class="line">    S-&gt;top = <span class="keyword">new</span>;</span><br><span class="line">    S-&gt;height++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove int from top of stack</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackPop</span><span class="params">(<span class="built_in">stack</span> S)</span> </span>&#123;</span><br><span class="line">    assert(S-&gt;height &gt; <span class="number">0</span>);</span><br><span class="line">    NodeT *head = S-&gt;top;</span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next;</span><br><span class="line">    S-&gt;height--;</span><br><span class="line">    <span class="keyword">int</span> d = head-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="queue-h"><a href="#queue-h" class="headerlink" title="queue.h"></a>queue.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueRep</span> *<span class="title">queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">queue</span> <span class="title">newQueue</span><span class="params">()</span></span>;               <span class="comment">// set up empty queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">dropQueue</span><span class="params">(<span class="built_in">queue</span>)</span></span>;         <span class="comment">// remove unwanted queue</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">QueueIsEmpty</span><span class="params">(<span class="built_in">queue</span>)</span></span>;      <span class="comment">// check whether queue is empty</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">QueueEnqueue</span><span class="params">(<span class="built_in">queue</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">// insert an int at end of queue</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">QueueDequeue</span><span class="params">(<span class="built_in">queue</span>)</span></span>;      <span class="comment">// remove int from front of queue</span></span><br></pre></td></tr></table></figure>

<h4 id="queue-c"><a href="#queue-c" class="headerlink" title="queue.c"></a>queue.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; NodeT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueRep</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>   length;</span><br><span class="line">   NodeT *head;</span><br><span class="line">   NodeT *tail;</span><br><span class="line">&#125; QueueRep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up empty queue</span></span><br><span class="line"><span class="function"><span class="built_in">queue</span> <span class="title">newQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">queue</span> Q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueRep));</span><br><span class="line">   Q-&gt;length = <span class="number">0</span>;</span><br><span class="line">   Q-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">   Q-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove unwanted queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dropQueue</span><span class="params">(<span class="built_in">queue</span> Q)</span> </span>&#123;</span><br><span class="line">   NodeT *curr = Q-&gt;head;</span><br><span class="line">   <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      NodeT *temp = curr-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(curr);</span><br><span class="line">      curr = temp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether queue is empty</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueIsEmpty</span><span class="params">(<span class="built_in">queue</span> Q)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (Q-&gt;length == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert an int at end of queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueEnqueue</span><span class="params">(<span class="built_in">queue</span> Q, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">   NodeT *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NodeT));</span><br><span class="line">   assert(<span class="keyword">new</span> != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">new</span>-&gt;data = v;</span><br><span class="line">   <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span> (Q-&gt;tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Q-&gt;tail-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">      Q-&gt;tail = <span class="keyword">new</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Q-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">      Q-&gt;tail = <span class="keyword">new</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Q-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove int from front of queue// Queue ADT implementation ... COMP9024 20T2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; NodeT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueRep</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>   length;</span><br><span class="line">   NodeT *head;</span><br><span class="line">   NodeT *tail;</span><br><span class="line">&#125; QueueRep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up empty queue</span></span><br><span class="line"><span class="function"><span class="built_in">queue</span> <span class="title">newQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">queue</span> Q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueRep));</span><br><span class="line">   Q-&gt;length = <span class="number">0</span>;</span><br><span class="line">   Q-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">   Q-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove unwanted queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dropQueue</span><span class="params">(<span class="built_in">queue</span> Q)</span> </span>&#123;</span><br><span class="line">   NodeT *curr = Q-&gt;head;</span><br><span class="line">   <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      NodeT *temp = curr-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(curr);</span><br><span class="line">      curr = temp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether queue is empty</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueIsEmpty</span><span class="params">(<span class="built_in">queue</span> Q)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (Q-&gt;length == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert an int at end of queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueEnqueue</span><span class="params">(<span class="built_in">queue</span> Q, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">   NodeT *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NodeT));</span><br><span class="line">   assert(<span class="keyword">new</span> != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">new</span>-&gt;data = v;</span><br><span class="line">   <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span> (Q-&gt;tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Q-&gt;tail-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">      Q-&gt;tail = <span class="keyword">new</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Q-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">      Q-&gt;tail = <span class="keyword">new</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Q-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove int from front of queue</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueDequeue</span><span class="params">(<span class="built_in">queue</span> Q)</span> </span>&#123;</span><br><span class="line">   assert(Q-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">   NodeT *p = Q-&gt;head;</span><br><span class="line">   Q-&gt;head = Q-&gt;head-&gt;next;</span><br><span class="line">   <span class="keyword">if</span> (Q-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Q-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Q-&gt;length--;</span><br><span class="line">   <span class="keyword">int</span> d = p-&gt;data;</span><br><span class="line">   <span class="built_in">free</span>(p);</span><br><span class="line">   <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="list-h"><a href="#list-h" class="headerlink" title="list.h"></a>list.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">List</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">insertLL</span><span class="params">(List, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">deleteLL</span><span class="params">(List, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inLL</span><span class="params">(List, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeLL</span><span class="params">(List)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showLL</span><span class="params">(List)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="list-c"><a href="#list-c" class="headerlink" title="list.c"></a>list.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>         v;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">makeNode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   Node *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   assert(<span class="keyword">new</span> != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">new</span>-&gt;v = n;</span><br><span class="line">   <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">insertLL</span><span class="params">(List L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (inLL(L, n))</span><br><span class="line">      <span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// add new node at the beginning</span></span><br><span class="line">   Node *<span class="keyword">new</span> = makeNode(n);</span><br><span class="line">   <span class="keyword">new</span>-&gt;next = L;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">deleteLL</span><span class="params">(List L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> L;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L-&gt;v == n) &#123;</span><br><span class="line">      Node *p = L-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(L);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      L-&gt;next = deleteLL(L-&gt;next, n);</span><br><span class="line">      <span class="keyword">return</span> L;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inLL</span><span class="params">(List L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (L-&gt;v == n)</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> inLL(L-&gt;next, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showLL</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L-&gt;v);</span><br><span class="line">      showLL(L-&gt;next);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeLL</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      freeLL(L-&gt;next);</span><br><span class="line">      <span class="built_in">free</span>(L);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><h4 id="graph-h"><a href="#graph-h" class="headerlink" title="graph.h"></a>graph.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphRep</span> *<span class="title">Graph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vertices are ints</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// edges are pairs of vertices (end-points)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">   Vertex v;</span><br><span class="line">   Vertex w;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">newGraph</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">numOfVertices</span><span class="params">(Graph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">insertEdge</span><span class="params">(Graph, Edge)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">removeEdge</span><span class="params">(Graph, Edge)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">adjacent</span><span class="params">(Graph, Vertex, Vertex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">showGraph</span><span class="params">(Graph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">freeGraph</span><span class="params">(Graph)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="graph-c-Adjacency-Matrix"><a href="#graph-c-Adjacency-Matrix" class="headerlink" title="graph.c(Adjacency Matrix)"></a>graph.c(Adjacency Matrix)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adjacency Matrix Representation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphRep</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>  **edges;   <span class="comment">// adjacency matrix</span></span><br><span class="line">   <span class="keyword">int</span>    nV;      <span class="comment">// #vertices</span></span><br><span class="line">   <span class="keyword">int</span>    nE;      <span class="comment">// #edges</span></span><br><span class="line">&#125; GraphRep;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">newGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">   assert(V &gt;= <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   Graph g = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphRep));</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line">   g-&gt;nV = V;</span><br><span class="line">   g-&gt;nE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// allocate memory for each row</span></span><br><span class="line">   g-&gt;edges = <span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">   assert(g-&gt;edges != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">// allocate memory for each column and initialise with 0</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">      g-&gt;edges[i] = <span class="built_in">calloc</span>(V, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">      assert(g-&gt;edges[i] != <span class="literal">NULL</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfVertices</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g-&gt;nV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if vertex is valid in a graph</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validV</span><span class="params">(Graph g, Vertex v)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (g != <span class="literal">NULL</span> &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt; g-&gt;nV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,e.v) &amp;&amp; validV(g,e.w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!g-&gt;edges[e.v][e.w]) &#123;  <span class="comment">// edge e not in graph</span></span><br><span class="line">      g-&gt;edges[e.v][e.w] = <span class="number">1</span>;</span><br><span class="line">      g-&gt;edges[e.w][e.v] = <span class="number">1</span>;</span><br><span class="line">      g-&gt;nE++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,e.v) &amp;&amp; validV(g,e.w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (g-&gt;edges[e.v][e.w]) &#123;   <span class="comment">// edge e in graph</span></span><br><span class="line">      g-&gt;edges[e.v][e.w] = <span class="number">0</span>;</span><br><span class="line">      g-&gt;edges[e.w][e.v] = <span class="number">0</span>;</span><br><span class="line">      g-&gt;nE--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">adjacent</span><span class="params">(Graph g, Vertex v, Vertex w)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,v) &amp;&amp; validV(g,w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> (g-&gt;edges[v][w] != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    assert(g != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of vertices: %d\n&quot;</span>, g-&gt;nV);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of edges: %d\n&quot;</span>, g-&gt;nE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;nV; i++)</span><br><span class="line">       <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; g-&gt;nV; j++)</span><br><span class="line">	  <span class="keyword">if</span> (g-&gt;edges[i][j])</span><br><span class="line">	      <span class="built_in">printf</span>(<span class="string">&quot;Edge %d - %d\n&quot;</span>, i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;nV; i++)</span><br><span class="line">      <span class="built_in">free</span>(g-&gt;edges[i]);</span><br><span class="line">   <span class="built_in">free</span>(g-&gt;edges);</span><br><span class="line">   <span class="built_in">free</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="graph-c-Adjacency-List"><a href="#graph-c-Adjacency-List" class="headerlink" title="graph.c(Adjacency List)"></a>graph.c(Adjacency List)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphRep</span> &#123;</span></span><br><span class="line">   List *edges;  <span class="comment">// array of lists</span></span><br><span class="line">   <span class="keyword">int</span>   nV;     <span class="comment">// #vertices</span></span><br><span class="line">   <span class="keyword">int</span>   nE;     <span class="comment">// #edges</span></span><br><span class="line">&#125; GraphRep;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">newGraph</span><span class="params">(<span class="keyword">int</span> nV)</span> </span>&#123;</span><br><span class="line">   assert(nV &gt;= <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   Graph g = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphRep));</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line">   g-&gt;nV = nV;</span><br><span class="line">   g-&gt;nE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// allocate memory for array of lists</span></span><br><span class="line">   g-&gt;edges = <span class="built_in">malloc</span>(nV * <span class="keyword">sizeof</span>(List));</span><br><span class="line">   assert(g-&gt;edges != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">// all adjacency lists initially empty</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nV; i++)</span><br><span class="line">      g-&gt;edges[i] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfVertices</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g-&gt;nV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if vertex is valid in a graph</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validV</span><span class="params">(Graph g, Vertex v)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (g != <span class="literal">NULL</span> &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt; g-&gt;nV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,e.v) &amp;&amp; validV(g,e.w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!inLL(g-&gt;edges[e.v], e.w)) &#123;   <span class="comment">// edge e not in graph</span></span><br><span class="line">      g-&gt;edges[e.v] = insertLL(g-&gt;edges[e.v], e.w);</span><br><span class="line">      g-&gt;edges[e.w] = insertLL(g-&gt;edges[e.w], e.v);</span><br><span class="line">      g-&gt;nE++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,e.v) &amp;&amp; validV(g,e.w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (inLL(g-&gt;edges[e.v], e.w)) &#123;   <span class="comment">// edge e in graph</span></span><br><span class="line">      g-&gt;edges[e.v] = deleteLL(g-&gt;edges[e.v], e.w);</span><br><span class="line">      g-&gt;edges[e.w] = deleteLL(g-&gt;edges[e.w], e.v);</span><br><span class="line">      g-&gt;nE--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">adjacent</span><span class="params">(Graph g, Vertex v, Vertex w)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,v));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> inLL(g-&gt;edges[v], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    assert(g != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of vertices: %d\n&quot;</span>, g-&gt;nV);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of edges: %d\n&quot;</span>, g-&gt;nE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;nV; i++) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d - &quot;</span>, i);</span><br><span class="line">       showLL(g-&gt;edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;nV; i++)</span><br><span class="line">      freeLL(g-&gt;edges[i]);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(g-&gt;edges);</span><br><span class="line">   <span class="built_in">free</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="graph-c-Adjacency-List-1"><a href="#graph-c-Adjacency-List-1" class="headerlink" title="graph.c(Adjacency List)"></a>graph.c(Adjacency List)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENOUGH 10000  <span class="comment">// maximum number of edges</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphRep</span> &#123;</span></span><br><span class="line">   Edge *edges; <span class="comment">// array of edges</span></span><br><span class="line">   <span class="keyword">int</span>   nV;    <span class="comment">// #vertices (numbered 0..nV-1)</span></span><br><span class="line">   <span class="keyword">int</span>   nE;    <span class="comment">// #edges</span></span><br><span class="line">   <span class="keyword">int</span>   n;     <span class="comment">// size of edge array</span></span><br><span class="line">&#125; GraphRep;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">newGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">   assert(V &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   Graph g = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphRep));</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   g-&gt;nV = V;</span><br><span class="line">   g-&gt;nE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// allocate enough memory for edges</span></span><br><span class="line">   g-&gt;n = ENOUGH;</span><br><span class="line">   g-&gt;edges = <span class="built_in">malloc</span>(g-&gt;n * <span class="keyword">sizeof</span>(Edge));</span><br><span class="line">   assert(g-&gt;edges != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfVertices</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g-&gt;nV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if two edges are equal</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eq</span><span class="params">(Edge e1, Edge e2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ( (e1.v == e2.v &amp;&amp; e1.w == e2.w)</span><br><span class="line">	    || (e1.v == e2.w &amp;&amp; e1.w == e2.v) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ensure that g exists and array of edges isn&#x27;t full</span></span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; g-&gt;nE &lt; g-&gt;n);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (i &lt; g-&gt;nE &amp;&amp; !eq(e, g-&gt;edges[i]))</span><br><span class="line">      i++;</span><br><span class="line">   <span class="keyword">if</span> (i == g-&gt;nE)                     <span class="comment">// edge e not found</span></span><br><span class="line">      g-&gt;edges[g-&gt;nE++] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);                 <span class="comment">// ensure that g exists</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (i &lt; g-&gt;nE &amp;&amp; !eq(e, g-&gt;edges[i]))</span><br><span class="line">      i++;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; g-&gt;nE)                      <span class="comment">// edge e found</span></span><br><span class="line">      g-&gt;edges[i] = g-&gt;edges[--g-&gt;nE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">adjacent</span><span class="params">(Graph g, Vertex x, Vertex y)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   Edge e;</span><br><span class="line">   e.v = x; e.w = y;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (i &lt; g-&gt;nE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (eq(e, g-&gt;edges[i]))</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    assert(g != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of vertices: %d\n&quot;</span>, g-&gt;nV);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of edges: %d\n&quot;</span>, g-&gt;nE);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;nE; i++)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Edge %d - %d\n&quot;</span>, g-&gt;edges[i].v, g-&gt;edges[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(g-&gt;edges);</span><br><span class="line">   <span class="built_in">free</span>(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Weighted-Graph"><a href="#Weighted-Graph" class="headerlink" title="Weighted Graph"></a>Weighted Graph</h3><h4 id="WGraph-h"><a href="#WGraph-h" class="headerlink" title="WGraph.h"></a>WGraph.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphRep</span> *<span class="title">Graph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vertices are ints</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// edges are pairs of vertices (end-points) with a weight</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">   Vertex v;</span><br><span class="line">   Vertex w;</span><br><span class="line">   <span class="keyword">int</span>    weight;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">newGraph</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">numOfVertices</span><span class="params">(Graph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">insertEdge</span><span class="params">(Graph, Edge)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">removeEdge</span><span class="params">(Graph, Edge)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">adjacent</span><span class="params">(Graph, Vertex, Vertex)</span></span>;  <span class="comment">// returns weight, or 0 if not adjacent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">showGraph</span><span class="params">(Graph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">freeGraph</span><span class="params">(Graph)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="WGraph-c"><a href="#WGraph-c" class="headerlink" title="WGraph.c"></a>WGraph.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adjacency Matrix Representation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;WGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphRep</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> **edges;  <span class="comment">// adjacency matrix storing positive weights</span></span><br><span class="line">		 <span class="comment">// 0 if nodes not adjacent</span></span><br><span class="line">   <span class="keyword">int</span> nV;       <span class="comment">// #vertices</span></span><br><span class="line">   <span class="keyword">int</span> nE;       <span class="comment">// #edges</span></span><br><span class="line">&#125; GraphRep;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">newGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">   assert(V &gt;= <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   Graph g = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphRep));</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line">   g-&gt;nV = V;</span><br><span class="line">   g-&gt;nE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// allocate memory for each row</span></span><br><span class="line">   g-&gt;edges = <span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">   assert(g-&gt;edges != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">// allocate memory for each column and initialise with 0</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">      g-&gt;edges[i] = <span class="built_in">calloc</span>(V, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">      assert(g-&gt;edges[i] != <span class="literal">NULL</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfVertices</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g-&gt;nV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if vertex is valid in a graph</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">validV</span><span class="params">(Graph g, Vertex v)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (g != <span class="literal">NULL</span> &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt; g-&gt;nV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,e.v) &amp;&amp; validV(g,e.w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (g-&gt;edges[e.v][e.w] == <span class="number">0</span>) &#123;   <span class="comment">// edge e not in graph</span></span><br><span class="line">      g-&gt;edges[e.v][e.w] = e.weight;</span><br><span class="line">      g-&gt;nE++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(Graph g, Edge e)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,e.v) &amp;&amp; validV(g,e.w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (g-&gt;edges[e.v][e.w] != <span class="number">0</span>) &#123;   <span class="comment">// edge e in graph</span></span><br><span class="line">      g-&gt;edges[e.v][e.w] = <span class="number">0</span>;</span><br><span class="line">      g-&gt;nE--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adjacent</span><span class="params">(Graph g, Vertex v, Vertex w)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span> &amp;&amp; validV(g,v) &amp;&amp; validV(g,w));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> g-&gt;edges[v][w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    assert(g != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of vertices: %d\n&quot;</span>, g-&gt;nV);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of edges: %d\n&quot;</span>, g-&gt;nE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;nV; i++)</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g-&gt;nV; j++)</span><br><span class="line">	  <span class="keyword">if</span> (g-&gt;edges[i][j] != <span class="number">0</span>)</span><br><span class="line">	     <span class="built_in">printf</span>(<span class="string">&quot;Edge %d - %d: %d\n&quot;</span>, i, j, g-&gt;edges[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeGraph</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">   assert(g != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;nV; i++)</span><br><span class="line">      <span class="built_in">free</span>(g-&gt;edges[i]);</span><br><span class="line">   <span class="built_in">free</span>(g-&gt;edges);</span><br><span class="line">   <span class="built_in">free</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><h4 id="BST-h"><a href="#BST-h" class="headerlink" title="BST.h"></a>BST.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Item;      <span class="comment">// item is just a key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">newTree</span><span class="params">()</span></span>;        <span class="comment">// create an empty Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(Tree)</span></span>;   <span class="comment">// free memory associated with Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTree</span><span class="params">(Tree)</span></span>;   <span class="comment">// display a Tree (sideways)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeSearch</span><span class="params">(Tree, Item)</span></span>;   <span class="comment">// check whether an item is in a Tree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">TreeHeight</span><span class="params">(Tree)</span></span>;         <span class="comment">// compute height of Tree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">TreeNumNodes</span><span class="params">(Tree)</span></span>;       <span class="comment">// count #nodes in Tree</span></span><br><span class="line"><span class="function">Tree <span class="title">TreeInsert</span><span class="params">(Tree, Item)</span></span>;   <span class="comment">// insert a new item into a Tree</span></span><br><span class="line"><span class="function">Tree <span class="title">TreeDelete</span><span class="params">(Tree, Item)</span></span>;   <span class="comment">// delete an item from a Tree</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal functions made visible for testing</span></span><br><span class="line"><span class="function">Tree <span class="title">rotateRight</span><span class="params">(Tree)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">rotateLeft</span><span class="params">(Tree)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">insertAtRoot</span><span class="params">(Tree, Item)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="BST-c"><a href="#BST-c" class="headerlink" title="BST.c"></a>BST.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BSTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> data(tree)  ((tree)-&gt;data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> left(tree)  ((tree)-&gt;left)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> right(tree) ((tree)-&gt;right)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>  data;</span><br><span class="line">   Tree left, right;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a new node containing data</span></span><br><span class="line"><span class="function">Tree <span class="title">newNode</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">   Tree <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   assert(<span class="keyword">new</span> != <span class="literal">NULL</span>);</span><br><span class="line">   data(<span class="keyword">new</span>) = it;</span><br><span class="line">   left(<span class="keyword">new</span>) = right(<span class="keyword">new</span>) = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new empty Tree</span></span><br><span class="line"><span class="function">Tree <span class="title">newTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free memory associated with Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(Tree t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      freeTree(left(t));</span><br><span class="line">      freeTree(right(t));</span><br><span class="line">      <span class="built_in">free</span>(t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// display Tree sideways</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTreeR</span><span class="params">(Tree t, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      showTreeR(right(t), depth+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">	 <span class="built_in">putchar</span>(<span class="string">&#x27;\t&#x27;</span>);            <span class="comment">// TAB character</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, data(t));</span><br><span class="line">      showTreeR(left(t), depth+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTree</span><span class="params">(Tree t)</span> </span>&#123;</span><br><span class="line">   showTreeR(t, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute height of Tree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeHeight</span><span class="params">(Tree t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// not yet implemented</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count #nodes in Tree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeNumNodes</span><span class="params">(Tree t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + TreeNumNodes(left(t)) + TreeNumNodes(right(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether a key is in a Tree</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeSearch</span><span class="params">(Tree t, Item it)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (it &lt; data(t))</span><br><span class="line">      <span class="keyword">return</span> TreeSearch(left(t), it);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (it &gt; data(t))</span><br><span class="line">      <span class="keyword">return</span> TreeSearch(right(t), it);</span><br><span class="line">   <span class="keyword">else</span>                                 <span class="comment">// it == data(t)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert a new item into a Tree</span></span><br><span class="line"><span class="function">Tree <span class="title">TreeInsert</span><span class="params">(Tree t, Item it)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">      t = newNode(it);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (it &lt; data(t))</span><br><span class="line">      left(t) = TreeInsert(left(t), it);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (it &gt; data(t))</span><br><span class="line">      right(t) = TreeInsert(right(t), it);</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">joinTrees</span><span class="params">(Tree t1, Tree t2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> t2;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> t1;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      Tree curr = t2;</span><br><span class="line">      Tree parent = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">while</span> (left(curr) != <span class="literal">NULL</span>) &#123;    <span class="comment">// find min element in t2</span></span><br><span class="line">	 parent = curr;</span><br><span class="line">	 curr = left(curr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 left(parent) = right(curr);  <span class="comment">// unlink min element from parent</span></span><br><span class="line">	 right(curr) = t2;</span><br><span class="line">      &#125;</span><br><span class="line">      left(curr) = t1;</span><br><span class="line">      <span class="keyword">return</span> curr;                    <span class="comment">// min element is new root</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete an item from a Tree</span></span><br><span class="line"><span class="function">Tree <span class="title">TreeDelete</span><span class="params">(Tree t, Item it)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it &lt; data(t))</span><br><span class="line">	 left(t) = TreeDelete(left(t), it);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (it &gt; data(t))</span><br><span class="line">	 right(t) = TreeDelete(right(t), it);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">	 Tree <span class="keyword">new</span>;</span><br><span class="line">	 <span class="keyword">if</span> (left(t) == <span class="literal">NULL</span> &amp;&amp; right(t) == <span class="literal">NULL</span>) </span><br><span class="line">	    <span class="keyword">new</span> = <span class="literal">NULL</span>;</span><br><span class="line">	 <span class="keyword">else</span> <span class="keyword">if</span> (left(t) == <span class="literal">NULL</span>)    <span class="comment">// if only right subtree, make it the new root</span></span><br><span class="line">	    <span class="keyword">new</span> = right(t);</span><br><span class="line">	 <span class="keyword">else</span> <span class="keyword">if</span> (right(t) == <span class="literal">NULL</span>)   <span class="comment">// if only left subtree, make it the new root</span></span><br><span class="line">	    <span class="keyword">new</span> = left(t);</span><br><span class="line">	 <span class="keyword">else</span>                         <span class="comment">// left(t) != NULL and right(t) != NULL</span></span><br><span class="line">	    <span class="keyword">new</span> = joinTrees(left(t), right(t));</span><br><span class="line">	 <span class="built_in">free</span>(t);</span><br><span class="line">	 t = <span class="keyword">new</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">rotateRight</span><span class="params">(Tree n1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n1 == <span class="literal">NULL</span> || left(n1) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> n1;</span><br><span class="line">   Tree n2 = left(n1);</span><br><span class="line">   left(n1) = right(n2);</span><br><span class="line">   right(n2) = n1;</span><br><span class="line">   <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">rotateLeft</span><span class="params">(Tree n2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n2 == <span class="literal">NULL</span> || right(n2) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> n2;</span><br><span class="line">   Tree n1 = right(n2);</span><br><span class="line">   right(n2) = left(n1);</span><br><span class="line">   left(n1) = n2;</span><br><span class="line">   <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">insertAtRoot</span><span class="params">(Tree t, Item it)</span> </span>&#123; </span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      t = newNode(it);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it &lt; data(t)) &#123;</span><br><span class="line">      left(t) = insertAtRoot(left(t), it);</span><br><span class="line">      t = rotateRight(t);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it &gt; data(t)) &#123;</span><br><span class="line">      right(t) = insertAtRoot(right(t), it);</span><br><span class="line">      t = rotateLeft(t);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RBT"><a href="#RBT" class="headerlink" title="RBT"></a>RBT</h3><h4 id="RBT-h"><a href="#RBT-h" class="headerlink" title="RBT.h"></a>RBT.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Item;      <span class="comment">// item is just a key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">newTree</span><span class="params">()</span></span>;        <span class="comment">// create an empty Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(Tree)</span></span>;   <span class="comment">// free memory associated with Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTree</span><span class="params">(Tree)</span></span>;   <span class="comment">// display a Tree (sideways)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeSearch</span><span class="params">(Tree, Item)</span></span>;   <span class="comment">// check whether an item is in a Tree</span></span><br><span class="line"><span class="function">Tree <span class="title">TreeInsert</span><span class="params">(Tree, Item)</span></span>;   <span class="comment">// insert a new item into a Tree</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="RBT-c"><a href="#RBT-c" class="headerlink" title="RBT.c"></a>RBT.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;RBTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_COLOUR_RED   <span class="meta-string">&quot;\x1B[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_COLOUR_RESET <span class="meta-string">&quot;\x1B[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> data(tree)   ((tree)-&gt;data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> left(tree)   ((tree)-&gt;left)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> right(tree)  ((tree)-&gt;right)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> colour(tree) ((tree)-&gt;colour)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isRed(tree)  ((tree) != NULL &amp;&amp; (tree)-&gt;colour == RED)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED,BLACK&#125; Colr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>  data;</span><br><span class="line">   Colr colour;</span><br><span class="line">   Tree left, right;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new empty Tree</span></span><br><span class="line"><span class="function">Tree <span class="title">newTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a new node containing data</span></span><br><span class="line"><span class="function">Tree <span class="title">newNode</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">   Tree <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   assert(<span class="keyword">new</span> != <span class="literal">NULL</span>);</span><br><span class="line">   data(<span class="keyword">new</span>) = it;</span><br><span class="line">   colour(<span class="keyword">new</span>) = RED;</span><br><span class="line">   left(<span class="keyword">new</span>) = right(<span class="keyword">new</span>) = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">rotateRight</span><span class="params">(Tree)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">rotateLeft</span><span class="params">(Tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert a new item into a tree</span></span><br><span class="line"><span class="function">Tree <span class="title">TreeInsert</span><span class="params">(Tree t, Item it)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Not yet implemented.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Returning a fixed tree instead:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   Tree testTree = newNode(<span class="number">2</span>);</span><br><span class="line">   colour(testTree) = BLACK;</span><br><span class="line">   left(testTree) = newNode(<span class="number">1</span>);</span><br><span class="line">   right(testTree) = newNode(<span class="number">3</span>);</span><br><span class="line">   <span class="keyword">return</span> testTree;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether a key is in a Tree</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeSearch</span><span class="params">(Tree t, Item it)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (it &lt; data(t))</span><br><span class="line">      <span class="keyword">return</span> TreeSearch(left(t), it);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (it &gt; data(t))</span><br><span class="line">      <span class="keyword">return</span> TreeSearch(right(t), it);</span><br><span class="line">   <span class="keyword">else</span>                                 <span class="comment">// it == data(t)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">rotateRight</span><span class="params">(Tree n1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n1 == <span class="literal">NULL</span> || left(n1) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> n1;</span><br><span class="line">   Tree n2 = left(n1);</span><br><span class="line">   left(n1) = right(n2);</span><br><span class="line">   right(n2) = n1;</span><br><span class="line">   <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">rotateLeft</span><span class="params">(Tree n2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n2 == <span class="literal">NULL</span> || right(n2) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> n2;</span><br><span class="line">   Tree n1 = right(n2);</span><br><span class="line">   right(n2) = left(n1);</span><br><span class="line">   left(n1) = n2;</span><br><span class="line">   <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free memory associated with Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(Tree t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      freeTree(left(t));</span><br><span class="line">      freeTree(right(t));</span><br><span class="line">      <span class="built_in">free</span>(t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// display Tree sideways</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTreeR</span><span class="params">(Tree t, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      showTreeR(right(t), depth+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">	 <span class="built_in">putchar</span>(<span class="string">&#x27;\t&#x27;</span>);            <span class="comment">// TAB character</span></span><br><span class="line">      <span class="keyword">if</span> (isRed(t))</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;%s%d%s\n&quot;</span>, PRINT_COLOUR_RED, data(t), PRINT_COLOUR_RESET);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, data(t));</span><br><span class="line">      showTreeR(left(t), depth+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTree</span><span class="params">(Tree t)</span> </span>&#123;</span><br><span class="line">   showTreeR(t, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><h4 id="Trie-h"><a href="#Trie-h" class="headerlink" title="Trie.h"></a>Trie.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  Item;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Trie</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Trie <span class="title">newTrie</span><span class="params">()</span></span>;        <span class="comment">// create an empty Trie</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTrie</span><span class="params">(Trie)</span></span>;   <span class="comment">// free memory associated with Trie</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTrie</span><span class="params">(Trie)</span></span>;   <span class="comment">// display a Trie (branch-by-branch)</span></span><br><span class="line"></span><br><span class="line"><span class="function">Trie <span class="title">TrieInsert</span><span class="params">(Trie, Key, Item)</span></span>;  <span class="comment">// insert a new item into a Trie</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Trie-c"><a href="#Trie-c" class="headerlink" title="Trie.c"></a>Trie.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Trie.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALPHABET_SIZE 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST_CHAR <span class="meta-string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO_ITEM 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">   <span class="keyword">bool</span> finish;       <span class="comment">// last char in key?</span></span><br><span class="line">   Item data;         <span class="comment">// NO_ITEM if !finish</span></span><br><span class="line">   Trie child[ALPHABET_SIZE];</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Trie <span class="title">newTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeTrie</span><span class="params">(Trie t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> c;</span><br><span class="line">      <span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; ALPHABET_SIZE; c++)</span><br><span class="line">	 freeTrie(t-&gt;child[c]);</span><br><span class="line">      <span class="built_in">free</span>(t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a new node</span></span><br><span class="line"><span class="function">Node *<span class="title">newNode</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   Trie <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   assert(<span class="keyword">new</span> != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">new</span>-&gt;finish = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">new</span>-&gt;data = NO_ITEM;</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line">   <span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; ALPHABET_SIZE; c++)</span><br><span class="line">      <span class="keyword">new</span>-&gt;child[c] = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Trie <span class="title">TrieInsert</span><span class="params">(Trie t, Key k, Item it)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">      t = newNode();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (k[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">      t-&gt;finish = <span class="literal">true</span>;</span><br><span class="line">      t-&gt;data = it;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> i = k[<span class="number">0</span>] - FIRST_CHAR;</span><br><span class="line">      t-&gt;child[i] = TrieInsert(t-&gt;child[i], k+<span class="number">1</span>, it);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> newline;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTrieR</span><span class="params">(Trie t, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, d;</span><br><span class="line">   <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (t-&gt;child[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (newline) &#123;                   <span class="comment">// just started a new line?</span></span><br><span class="line">	       <span class="keyword">for</span> (d = <span class="number">0</span>; d &lt; depth; d++)</span><br><span class="line">		  <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">	       newline = <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (<span class="keyword">char</span>)i + FIRST_CHAR);</span><br><span class="line">	    <span class="keyword">if</span> (t-&gt;child[i]-&gt;finish) &#123;</span><br><span class="line">	       <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, t-&gt;child[i]-&gt;data);</span><br><span class="line">	       newline = <span class="literal">true</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    showTrieR(t-&gt;child[i], depth+<span class="number">1</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTrie</span><span class="params">(Trie t)</span> </span>&#123;</span><br><span class="line">   newline = <span class="literal">false</span>;</span><br><span class="line">   showTrieR(t, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Michael Thielscher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://webcms3.cse.unsw.edu.au/COMP9024/20T2/">https://webcms3.cse.unsw.edu.au/COMP9024/20T2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Michael Thielscher所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a><a class="post-meta__tags" href="/tags/COMP9024/">COMP9024</a></div><div class="post_share"><div class="social-share" data-image="/img/Michael.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/15/Comp9024%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><img class="prev-cover" src="/img/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%951.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Comp9024算法总结</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/06/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F%E8%BF%87%E7%A8%8B/"><img class="next-cover" src="/img/timg.jfif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">本博客的进化过程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/15/Comp9024算法总结/" title="Comp9024算法总结"><img class="cover" src="/img/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%951.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-15</div><div class="title">Comp9024算法总结</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(/img/2am.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Louie Zedd</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我们遇到什么困难也不要怕，微笑着面对它！</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>